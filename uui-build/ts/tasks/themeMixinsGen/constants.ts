import { TFigmaThemeName } from '../themeTokensGen/types/sharedTypes';
import { PATH } from '../themeTokensGen/constants';
import { figmaVarComparator } from '../themeTokensGen/main';

const THEME_DIR = './epam-assets/theme';

export const tokensFile = PATH.FIGMA_VARS_COLLECTION_OUT_TOKENS;
export const coreThemeMixinsConfig: Record<TFigmaThemeName, { themeFile: string, mixinsFile: string }> = {
    [TFigmaThemeName.EPAM]: {
        themeFile: `${THEME_DIR}/theme_electric.scss`,
        mixinsFile: `${THEME_DIR}/theme_electric_mixins.scss`,
    },
    [TFigmaThemeName.PROMO]: {
        themeFile: `${THEME_DIR}/theme_promo.scss`,
        mixinsFile: `${THEME_DIR}/theme_promo_mixins.scss`,
    },
    [TFigmaThemeName.LOVESHIP_LIGHT]: {
        themeFile: `${THEME_DIR}/theme_loveship.scss`,
        mixinsFile: `${THEME_DIR}/theme_loveship_mixins.scss`,
    },
    [TFigmaThemeName.LOVESHIP_DARK]: {
        themeFile: `${THEME_DIR}/theme_loveship_dark.scss`,
        mixinsFile: `${THEME_DIR}/theme_loveship_dark_mixins.scss`,
    },
};

const INDENT_1 = new Array(4).fill(' ').join('');

export const coreMixinGenTemplate = (
    params: {
        scssVars: Map<string, string>,
        cssVarsByGroup: Record<string, Map<string, string>>,
        errors: string,
    },
): string => {
    const mixinName = 'theme_core-mixin';
    const {
        cssVarsByGroup = {},
        scssVars = new Map(),
        errors,
    } = params;

    const scssVarsStr = mapToSortedArr(scssVars).map(([name, value]) => {
        return `$${name}: ${value};`;
    }).join('\n');

    const groups = Object.keys(cssVarsByGroup);
    const cssVarsRes = groups.reduce<{ core: string, palette: string, rest: string }>((acc, groupId) => {
        const res = cssVarGroupToSCSS(cssVarsByGroup[groupId]);
        if (groupId.startsWith('core/')) {
            const LB = acc.core ? '\n\n' : '';
            acc.core += LB + res;
        } else if (groupId.startsWith('palette')) {
            const LB = acc.palette ? '\n\n' : '';
            acc.palette += LB + res;
        } else {
            const LB = acc.rest ? '\n\n' : '';
            acc.rest += LB + res;
        }
        return acc;
    }, { core: '', palette: '', rest: '' });

    return [
        '// This file is AUTOGENERATED from Figma!',
        errors ? `\n${errors}\n` : '',
        wrapGroupInComments(scssVarsStr, 'Private Figma vars', 0),
        '',
        `@mixin ${mixinName} {`,
        '',
        wrapGroupInComments(cssVarsRes.palette, 'Palette variables'),
        '',
        wrapGroupInComments(cssVarsRes.core, 'Core variables'),
        '',
        wrapGroupInComments(cssVarsRes.rest, 'Other variables'),
        '}',
        '',
    ].join('\n');
};

function cssVarGroupToSCSS(cssVars: Map<string, string>): string {
    return mapToSortedArr(cssVars).map(([name, value]) => {
        return `${INDENT_1}${name}: ${value};`;
    }).join('\n');
}

function mapToSortedArr(map: Map<string, unknown>) {
    return [...map.entries()].sort((e1, e2) => figmaVarComparator(e1[0], e2[0]));
}

function wrapGroupInComments(str: string, groupName: string, indent: number = 1) {
    const I = indent === 0 ? '' : INDENT_1;
    const start = `${I}/* "${groupName}" start */\n`;
    const end = `\n${I}/* "${groupName}" end */`;
    return [
        start,
        str,
        end,
    ].join('\n');
}
